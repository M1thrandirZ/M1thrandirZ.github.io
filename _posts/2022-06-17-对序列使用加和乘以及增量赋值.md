---
layout: post
author: Junda
tag: Python
---

+操作可以把两个相同类型的数据拼接起来，并新建一个新的序列用来输出结果。*操作可以把一个序列复制几份然后再拼接起来。

```python
#code 0
l=[1,2,3]
print(l*5)
```

> [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]
> 

```python
#code 1
print(5*'abc')
```

> abcabcabcabcabc
> 

+和*都不修改原有的操作对象，而是构建一个全新的序列。

```python
#code 2
board=[[' _ ']*3 for i in range(3)]
print(board)
board[1][2]='x'
print(board)
```

> [[' _ ',' _ ',' _ ' ],[' _ ',' _ ',' _ ' ],[' _ ',' _ ',' _ ' ] ]
> 

> [[' _ ',' _ ',' _ ' ],[' _ ',' _ ',' x ' ],[' _ ',' _ ',' _ ' ] ]
> 

以下的列表初始化方法是错误的。

```python
#code 3
wrong_board=[[' _ ']*3]*3
print(wrong_board)
```

> [[' _ ',' _ ',' 0 ' ],[' _ ',' _ ',' 0 ' ],[' _ ',' _ ',' 0 ' ] ]
> 

code 3中是对同一个[' _ ']*3对象的三次引用，改变一个就改变了所有。

增量复制运算符+=和*=的表现取决于它们的第一个操作对象。背后都是以特殊方法（__ iadd__或者__ imul__）来实现“就地加法或就地乘法”，计算过程中不会产生新的变量。如果操作对象没有实现上述特殊方法，则会调用__add__或__mul__方法，先计算得到一个新值，然后赋值给原来的变量。

```python
#code 4
l=[1,2,3]
print(id(l))#获取变量的id
l*=2
print(id(l))#就地乘法，id没有变
t=(1,2,3)
print(id(t))
t*=2
print(id(t))#因为tuple是不可变序列，所以必须新建一个变量作为结果
```

> 2634201582912<br>
2634201582912<br>
2634204478080<br>
2634201926528
> 

对不可变序列（tuple、bytes）进行重复拼接操作的效率很低，因为每次都有新的变量产生，还需要进行复制操作。str是个例外，因为对其的拼接太常用，CPython特别做了优化。