---
layout: post
author: Junda
tag: Python
---

对于in操作，不管查询有多少个元素的字典或集合，所消耗的时间都是能忽略不计的。而列表每次实现in操作都需要扫描一次完整的列表。这其中的区别是因为前两者是通过散列表实现的。

### 散列值和相等性

**散列表**（哈希表）其实是一个稀疏的数组，即总是有空白元素的数组。计算一个对象的散列值可以使用内置函数hash()，该函数可以应用在所有的内置类型对象上。如果两个对象在比较时相等，则它们的哈希值也必定相等。但它们可能属于不同的数据类型，如1==1.0。

哈希的原理决定了，理想状态下，越是相似的两个对象，其哈希结果差别越大。

### 散列表算法

为了获取 y_dict [ search_key ］背后的值， Python 首先会调用 hash ( search_key ）来计算 search_key 的散列值，把这个值最低的几位数字当作偏移量，在散列表里查找表元（具体取几位，得看当前散列表的大小）。若找到的表元是空的，则抛出 KeyError 异常。若不是空的，则表元里会有一对 found_key : found_value 。这时候 Python 会检验 search key == found_key 是否为真，如果它们相等的话，就会返回 found_value 。
如果 search_key 和 found_key 不匹配的话，这种情况称为**散列冲突**。发生这种情况是因为，散列表所做的其实是把随机的元素映射到只有几位的数字上，而散列表本身的索引又只依赖于这个数字的一部分。为了解决散列冲突，算法会在散列值中另外再取几位，然后用特殊的方法处理一下，把新得到的数字再当作索引来寻找表元。若这次找到的表元是空的，则同样抛出 KeyError ；若非空，或者键匹配，则返回这个值，或者又发现了散列冲突，则重复以上的步骤。

### 因散列表而产生的性质

因为dict基于散列表而实现，因此会有如下优势和限制：

1. 键必须是可散列的；
    1. 支持hash()函数，并通过__hash()__方法得到的散列值是不变的。
    2. 支持通过__eq()__方法检测相等性。
    3. 若a==b为真，则hash(a)==hash(b)为真。
2. 字典在内存上的开销巨大；
3. 键查询速度很快；
4. 键的次序取决于添加顺序；
5. 往字典里添加新的键有可能会改变现有键的顺序，因此不要对字典进行迭代同时修改。